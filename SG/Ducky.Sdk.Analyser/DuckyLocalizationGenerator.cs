using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ducky.Sdk.Analyser;

/// <summary>
/// Incremental source generator that mirrors LK key constants into a strongly-typed
/// facade on L with properties that return localized strings via L.Get(key).
///
/// Convention:
/// - Reads nested static classes and const string fields.
/// - Emits partial class L with matching nested static classes and properties.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DuckyLocalizationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Discover LK class declarations by syntax, then enrich with semantic model
        var lkProvider = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is ClassDeclarationSyntax cds && cds.Identifier.Text == "LK",
            static (ctx, ct) => TransformLK(ctx, ct))
            .Where(static info => info is not null)!
            .Select((info, _) => info!);

        // Collect all (usually one) LK descriptors and generate once
        var collected = lkProvider.Collect();
        context.RegisterSourceOutput(collected, static (spc, list) =>
        {
            if (!list.Any())
            {
                return;
            }

            // Now generate for every discovered LK in the compilation.
            foreach (var lk in list)
            {
                if (lk is null) continue;
                Emit(spc, lk);
                EmitKeyListAndHash(spc, lk);
            }
        });
    }

    private static LKDescriptor? TransformLK(GeneratorSyntaxContext ctx, CancellationToken ct)
    {
        var cds = (ClassDeclarationSyntax)ctx.Node;
        if (ctx.SemanticModel.GetDeclaredSymbol(cds, ct) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var ns = symbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty) ?? string.Empty;

        // Only consider static classes named LK
        if (symbol.Name != "LK" || symbol.TypeKind != TypeKind.Class || !symbol.IsStatic)
        {
            return null;
        }

        var groups = new List<GroupDescriptor>();
        foreach (var nested in symbol.GetTypeMembers())
        {
            // Only nested static classes
            if (!nested.IsStatic || nested.TypeKind != TypeKind.Class)
            {
                continue;
            }

            var entries = new List<EntryDescriptor>();
            foreach (var member in nested.GetMembers())
            {
                if (member is IFieldSymbol field && field.IsConst && field.Type.SpecialType == SpecialType.System_String)
                {
                    var name = field.Name;
                    var value = field.ConstantValue as string ?? string.Empty;
                    if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(value))
                    {
                        entries.Add(new EntryDescriptor(name, value));
                    }
                }
            }

            if (entries.Count > 0)
            {
                groups.Add(new GroupDescriptor(nested.Name, entries));
            }
        }

        if (groups.Count == 0)
        {
            return null;
        }

        return new LKDescriptor(ns, groups);
    }

    /// <summary>
    /// 生成 L 的部分类代码
    /// </summary>
    private static void Emit(SourceProductionContext spc, LKDescriptor lk)
    {

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/> DO NOT EDIT");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("namespace Ducky.Sdk.Localizations;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated strongly-typed accessors for BetterModLoader localizations.");
        sb.AppendLine("/// Mirrors LK constants as properties that call L.Get(…)");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public partial class L");
        sb.AppendLine("{");

        foreach (var group in lk.Groups.OrderBy(g => g.Name))
        {
            sb.AppendLine($"    /// <summary>Localized strings for {EscapeXml(group.Name)}</summary>");
            sb.AppendLine($"    public static class {EscapeIdentifier(group.Name)}");
            sb.AppendLine("    {");

            foreach (var entry in group.Entries.OrderBy(e => e.Name))
            {
                // Property that returns L.Get(LK.Group.Name)
                sb.AppendLine($"        /// <summary>Localized text for key: {EscapeXml(entry.Value)}</summary>");
                sb.AppendLine($"        public static string {EscapeIdentifier(entry.Name)} => Get(global::{lk.Namespace}.LK.{group.Name}.{entry.Name});");
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        // Use a file-name that includes the LK namespace so multiple LK from different namespaces
        // do not collide when generating in the same compilation.
        var fileName = $"L.GeneratedKeys.{MakeSafeFileName(lk.Namespace)}.g.cs";
        spc.AddSource(fileName, sb.ToString());
    }

    /// <summary>
    /// 生成所有 key 的列表和 hash 文件，供 MSBuild Task 使用
    /// </summary>
    private static void EmitKeyListAndHash(Microsoft.CodeAnalysis.SourceProductionContext spc, LKDescriptor lk)
    {
        // 收集所有 key（排除重复）
        var allKeys = lk.Groups
            .SelectMany(g => g.Entries)
            .Select(e => e.Value)
            .Distinct()
            .OrderBy(x => x)
            .ToList();

        // 生成 key 列表代码（供 MSBuild Task 或其它工具读取）
        var keyListCode = new StringBuilder();
        keyListCode.AppendLine("// <auto-generated/> DO NOT EDIT");
        keyListCode.AppendLine("#nullable enable");
        keyListCode.AppendLine($"namespace {lk.Namespace};");
        keyListCode.AppendLine("public static partial class LKeys");
        keyListCode.AppendLine("{");
        keyListCode.AppendLine("    /// <summary>所有 LK key 列表</summary>");
        keyListCode.AppendLine("    public static readonly string[] All = new string[] {");
        foreach (var key in allKeys)
        {
            keyListCode.AppendLine($"        \"{EscapeString(key)}\",");
        }
        keyListCode.AppendLine("    }; ");
        keyListCode.AppendLine("}");
        var keyListFile = $"LKeys.{MakeSafeFileName(lk.Namespace)}.g.cs";
        spc.AddSource(keyListFile, keyListCode.ToString());

        // 生成 hash 常量类（作为编译产物，MSBuild Task 将通过反射读取）
        var hash = ComputeSha256(string.Join("|", allKeys));
        var hashClass = new StringBuilder();
        hashClass.AppendLine("// <auto-generated/> DO NOT EDIT");
        hashClass.AppendLine("#nullable enable");
        hashClass.AppendLine($"namespace {lk.Namespace};");
        hashClass.AppendLine("public static partial class LocalsKeysHash");
        hashClass.AppendLine("{");
        hashClass.AppendLine($"    public const string Hash = \"{EscapeString(hash)}\";");
        hashClass.AppendLine("}");
        var hashFile = $"LocalsKeysHash.{MakeSafeFileName(lk.Namespace)}.g.cs";
        spc.AddSource(hashFile, hashClass.ToString());
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static string ComputeSha256(string input)
    {
        using var sha = System.Security.Cryptography.SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(input);
        var hash = sha.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", string.Empty).ToLowerInvariant();
    }

    private static string EscapeIdentifier(string name)
    {
        // Escape keywords or invalid identifiers minimally
        return Microsoft.CodeAnalysis.CSharp.SyntaxFacts.GetKeywordKind(name) != Microsoft.CodeAnalysis.CSharp.SyntaxKind.None ? "@" + name : name;
    }

    private static string EscapeXml(string text)
    {
        return text.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }

    private static string MakeSafeFileName(string ns)
    {
        if (string.IsNullOrWhiteSpace(ns))
        {
            return "global";
        }

        // Replace dots and invalid filename chars with '_' to create a predictable file name.
        var sb = new StringBuilder();
        foreach (var c in ns)
        {
            if (char.IsLetterOrDigit(c) || c == '_') sb.Append(c);
            else sb.Append('_');
        }
        return sb.ToString();
    }

    private sealed record LKDescriptor(string Namespace, IReadOnlyList<GroupDescriptor> Groups)
    {
        public string Namespace { get; } = Namespace;
        public IReadOnlyList<GroupDescriptor> Groups { get; } = Groups;
    }

    private sealed record GroupDescriptor(string Name, IReadOnlyList<EntryDescriptor> Entries)
    {
        public string Name { get; } = Name;
        public IReadOnlyList<EntryDescriptor> Entries { get; } = Entries;
    }

    private sealed record EntryDescriptor(string Name, string Value)
    {
        public string Name { get; } = Name;
        public string Value { get; } = Value;
    }
}
