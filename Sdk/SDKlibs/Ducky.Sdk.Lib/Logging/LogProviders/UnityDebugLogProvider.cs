// <auto-generated/>
// ReSharper disable CheckNamespace
namespace Ducky.Sdk.Logging.LogProviders
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq.Expressions;

#if LIBLOG_EXCLUDE_CODE_COVERAGE
    [ExcludeFromCodeCoverage]
#endif
    internal class UnityDebugLogProvider : LogProviderBase
    {
        private readonly Func<Type, object> _getLoggerByTypeDelegate;

        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "UnityEngine")]
        public UnityDebugLogProvider()
        {
            if (!IsLoggerAvailable()) throw new LibLogException("UnityEngine.Debug not found");
            _getLoggerByTypeDelegate = GetLoggerByType();
        }

        public static bool ProviderIsAvailableOverride { get; set; } = true;

        public override Logger GetLogger(string name)
        {
            // Unity Debug doesn't support named loggers, but we can use ILogger with tags
            var loggerType = Type.GetType(name) ?? typeof(UnityDebugLogProvider);
            return new UnityDebugLogger(loggerType, name).Log;
        }

        internal static bool IsLoggerAvailable()
            => ProviderIsAvailableOverride && GetDebugType() != null;

        private static Type GetDebugType()
            => FindType("UnityEngine.Debug", "UnityEngine");

        private static Func<Type, object> GetLoggerByType()
        {
            // Unity's ILogger can be obtained via Debug.unityLogger
            var debugType = GetDebugType();
            var unityLoggerProperty = debugType?.GetProperty("unityLogger");
            
            if (unityLoggerProperty != null)
            {
                var typeParam = Expression.Parameter(typeof(Type), "type");
                var propertyAccess = Expression.Property(null, unityLoggerProperty);
                var lambda = Expression.Lambda<Func<Type, object>>(propertyAccess, typeParam);
                return lambda.Compile();
            }

            // Fallback: just return null, we'll use Debug.Log directly
            return _ => null;
        }

#if LIBLOG_EXCLUDE_CODE_COVERAGE
    [ExcludeFromCodeCoverage]
#endif
        internal class UnityDebugLogger
        {
            private static Action<object> s_log;
            private static Action<object> s_logWarning;
            private static Action<object> s_logError;
            private static Action<Exception> s_logException;
            private static readonly Lazy<bool> Initialized = new Lazy<bool>(Initialize);
            private static Exception s_initializeException;
            private readonly Type _loggerType;
            private readonly string _loggerName;

            internal UnityDebugLogger(Type loggerType, string loggerName)
            {
                _loggerType = loggerType;
                _loggerName = loggerName;
            }

            [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "UnityEngine")]
            private static bool Initialize()
            {
                try
                {
                    var debugType = FindType("UnityEngine.Debug", "UnityEngine");
                    if (debugType == null)
                        throw new LibLogException("Type UnityEngine.Debug was not found.");

                    // Get Debug.Log(object) method
                    var logMethod = debugType.GetMethod("Log", new[] { typeof(object) });
                    var logWarningMethod = debugType.GetMethod("LogWarning", new[] { typeof(object) });
                    var logErrorMethod = debugType.GetMethod("LogError", new[] { typeof(object) });
                    var logExceptionMethod = debugType.GetMethod("LogException", new[] { typeof(Exception) });

                    if (logMethod == null || logWarningMethod == null || logErrorMethod == null || logExceptionMethod == null)
                        throw new LibLogException("Unity Debug logging methods were not found.");

                    // Create delegates for Debug.Log(object)
                    var messageParam = Expression.Parameter(typeof(object), "message");
                    var logCall = Expression.Call(null, logMethod, messageParam);
                    s_log = Expression.Lambda<Action<object>>(logCall, messageParam).Compile();

                    var logWarningCall = Expression.Call(null, logWarningMethod, messageParam);
                    s_logWarning = Expression.Lambda<Action<object>>(logWarningCall, messageParam).Compile();

                    var logErrorCall = Expression.Call(null, logErrorMethod, messageParam);
                    s_logError = Expression.Lambda<Action<object>>(logErrorCall, messageParam).Compile();

                    var exceptionParam = Expression.Parameter(typeof(Exception), "exception");
                    var logExceptionCall = Expression.Call(null, logExceptionMethod, exceptionParam);
                    s_logException = Expression.Lambda<Action<Exception>>(logExceptionCall, exceptionParam).Compile();
                }
                catch (Exception ex)
                {
                    s_initializeException = ex;
                    return false;
                }

                return true;
            }

            public bool Log(LogLevel logLevel, Func<string> messageFunc, Exception exception,
                params object[] formatParameters)
            {
                if (!Initialized.Value)
                    throw new LibLogException(ErrorInitializingProvider, s_initializeException);

                if (messageFunc == null)
                {
                    // Unity Debug is always enabled
                    return true;
                }

                var message = messageFunc();
                
                // Format the message with parameters if provided
                if (formatParameters != null && formatParameters.Length > 0)
                {
                    try
                    {
                        message = string.Format(message, formatParameters);
                    }
                    catch (FormatException)
                    {
                        // If formatting fails, just use the original message
                    }
                }

                // Prepend logger name for context
                var fullMessage = string.IsNullOrEmpty(_loggerName) 
                    ? message 
                    : $"[{_loggerName}] {message}";

                if (exception != null)
                {
                    // Log the message first, then the exception
                    LogMessage(logLevel, fullMessage);
                    s_logException(exception);
                }
                else
                {
                    LogMessage(logLevel, fullMessage);
                }

                return true;
            }

            private static void LogMessage(LogLevel logLevel, string message)
            {
                switch (logLevel)
                {
                    case LogLevel.Fatal:
                    case LogLevel.Error:
                        s_logError(message);
                        break;
                    case LogLevel.Warn:
                        s_logWarning(message);
                        break;
                    case LogLevel.Info:
                    case LogLevel.Debug:
                    case LogLevel.Trace:
                    default:
                        s_log(message);
                        break;
                }
            }
        }
    }
}
