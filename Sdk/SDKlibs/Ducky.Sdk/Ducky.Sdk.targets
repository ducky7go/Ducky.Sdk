<Project>
    <!-- Validation: At least one of DuckovFolder or SteamFolder must be set -->
    <Target Name="ValidateDuckovFolder" BeforeTargets="BeforeBuild">
        <Error Condition=" '$(DuckovFolder)' == '' AND '$(SteamFolder)' == '' "
               Text="Either DuckovFolder or SteamFolder must be specified. Please set one of them in your project or Local.props file." />
    </Target>

    <!-- Generate preview.png identicon if missing -->
    <Target Name="GeneratePreview" BeforeTargets="CopyToDuckov"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' ">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <_GeneratePreviewScriptInProject>$(MSBuildThisFileDirectory)../scripts/generate-preview.csx</_GeneratePreviewScriptInProject>
            <GeneratePreviewScriptPath Condition="$([System.IO.File]::Exists('$(_GeneratePreviewScriptInProject)'))">$(_GeneratePreviewScriptInProject)</GeneratePreviewScriptPath>
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <_PreviewPngPath>$([System.IO.Path]::Combine('$(AssetsDir)','preview.png'))</_PreviewPngPath>
        </PropertyGroup>

        <ItemGroup Condition="'$(GeneratePreviewScriptPath)' == ''">
            <_GeneratePreviewScriptFromContent Include="@(Compile)"
                                               Condition="'%(Filename)%(Extension)' == 'generate-preview.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <GeneratePreviewScriptPath
                Condition="'$(GeneratePreviewScriptPath)' == '' AND '@(_GeneratePreviewScriptFromContent)' != ''">
                %(_GeneratePreviewScriptFromContent.FullPath)
            </GeneratePreviewScriptPath>
        </PropertyGroup>

        <Message Text="[GeneratePreview] Checking for preview.png in assets..." Importance="high"
                 Condition="'$(GeneratePreviewScriptPath)' != '' AND !Exists('$(_PreviewPngPath)')" />
        <Message Text="  Assets Dir: $(AssetsDir)" Importance="high"
                 Condition="'$(GeneratePreviewScriptPath)' != '' AND !Exists('$(_PreviewPngPath)')" />

        <Exec Command="dotnet script &quot;$(GeneratePreviewScriptPath)&quot; &quot;$(AssetsDir)&quot;"
              ContinueOnError="true"
              IgnoreExitCode="true"
              WorkingDirectory="$(MSBuildProjectDirectory)"
              Condition="'$(GeneratePreviewScriptPath)' != '' AND !Exists('$(_PreviewPngPath)')">
            <Output TaskParameter="ExitCode" PropertyName="_GeneratePreviewExitCode" />
        </Exec>

        <Message Text="[GeneratePreview] Generation completed (exit code: $(_GeneratePreviewExitCode))"
                 Importance="high"
                 Condition="'$(_GeneratePreviewExitCode)' != ''" />
        <Message
            Text="[GeneratePreview] Script failed with exit code $(_GeneratePreviewExitCode), but continuing build"
            Importance="high"
            Condition="'$(_GeneratePreviewExitCode)' != '0' AND '$(_GeneratePreviewExitCode)' != ''" />
    </Target>

    <!-- Ensure info.ini exists in assets directory before any operations -->
    <Target Name="EnsureInfoIni" BeforeTargets="CollectFromMod;CopyToDuckov;Build"
            Condition=" '$(ModName)' != '' ">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <_EnsureInfoScriptInProject>$(MSBuildThisFileDirectory)../scripts/ensure-info-ini.csx</_EnsureInfoScriptInProject>
            <EnsureInfoScriptPath Condition="$([System.IO.File]::Exists('$(_EnsureInfoScriptInProject)'))">$(_EnsureInfoScriptInProject)</EnsureInfoScriptPath>
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
        </PropertyGroup>

        <ItemGroup Condition="'$(EnsureInfoScriptPath)' == ''">
            <_EnsureInfoScriptFromContent Include="@(Compile)"
                                          Condition="'%(Filename)%(Extension)' == 'ensure-info-ini.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <EnsureInfoScriptPath
                Condition="'$(EnsureInfoScriptPath)' == '' AND '@(_EnsureInfoScriptFromContent)' != ''">
                %(_EnsureInfoScriptFromContent.FullPath)
            </EnsureInfoScriptPath>
        </PropertyGroup>

        <Message Text="[EnsureInfoIni] Checking for info.ini in assets directory..." Importance="high"
                 Condition="'$(EnsureInfoScriptPath)' != ''" />

        <Exec
            Command="dotnet script &quot;$(EnsureInfoScriptPath)&quot; &quot;$(AssetsDir)&quot; &quot;$(ModName)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="true"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(EnsureInfoScriptPath)' != ''">
            <Output TaskParameter="ExitCode" PropertyName="_EnsureInfoExitCode" />
        </Exec>

        <Message Text="[EnsureInfoIni] Check completed (exit code: $(_EnsureInfoExitCode))" Importance="high"
                 Condition="'$(_EnsureInfoExitCode)' != ''" />
        <Message Text="[EnsureInfoIni] Script failed with exit code $(_EnsureInfoExitCode), but continuing build"
                 Importance="high"
                 Condition="'$(_EnsureInfoExitCode)' != '0' AND '$(_EnsureInfoExitCode)' != ''" />
    </Target>

    <!-- Collect publishedFileId from deployed mod back to source assets before copying -->
    <Target Name="CollectFromMod" BeforeTargets="CopyToDuckov"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' AND '$(_ShouldProcessLocalization)' == 'true' ">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <_CollectScriptInProject>$(MSBuildThisFileDirectory)../scripts/collect-from-mod.csx</_CollectScriptInProject>
            <CollectScriptPath Condition="$([System.IO.File]::Exists('$(_CollectScriptInProject)'))">$(_CollectScriptInProject)</CollectScriptPath>
            <!-- Fallback only: allow external override via /p:AssetsDir=... -->
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <_DeployedModDir>$(ModsDirectory)$(ModName)</_DeployedModDir>
        </PropertyGroup>

        <ItemGroup Condition="'$(CollectScriptPath)' == ''">
            <_CollectScriptFromContent Include="@(Compile)"
                                       Condition="'%(Filename)%(Extension)' == 'collect-from-mod.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <CollectScriptPath Condition="'$(CollectScriptPath)' == '' AND '@(_CollectScriptFromContent)' != ''">%(_CollectScriptFromContent.FullPath)</CollectScriptPath>
        </PropertyGroup>

        <Message Text="[CollectFromMod] Syncing publishedFileId from deployed mod to source assets..."
                 Importance="high"
                 Condition="'$(CollectScriptPath)' != '' AND Exists('$(_DeployedModDir)')" />
        <Message Text="  Script: $(CollectScriptPath)" Importance="high" Condition="'$(CollectScriptPath)' != ''" />
        <Message Text="  Deployed Mod: $(_DeployedModDir)" Importance="high" Condition="Exists('$(_DeployedModDir)')" />
        <Message Text="  Assets Dir: $(AssetsDir)" Importance="high" Condition="'$(CollectScriptPath)' != ''" />

        <Exec
            Command="dotnet script &quot;$(CollectScriptPath)&quot; &quot;$(_DeployedModDir)&quot; &quot;$(AssetsDir)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="true"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(CollectScriptPath)' != '' AND Exists('$(_DeployedModDir)')">
            <Output TaskParameter="ExitCode" PropertyName="_CollectExitCode" />
        </Exec>

        <Message Text="[CollectFromMod] Sync completed (exit code: $(_CollectExitCode))" Importance="high"
                 Condition="'$(_CollectExitCode)' != ''" />
        <Warning Text="[CollectFromMod] Script failed with exit code $(_CollectExitCode)"
                 Condition="'$(_CollectExitCode)' != '0' AND '$(_CollectExitCode)' != ''" />
    </Target>

    <Target Name="CopyToDuckov" AfterTargets="Build"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' ">
        <!-- Ensure destination folder exists -->
        <MakeDir Directories="$(ModsDirectory)$(ModName)" />

        <!-- copy preview.png and info.ini -->
        <Copy SourceFiles="@(AssetsFiles)"
              DestinationFiles="@(AssetsFiles->'$(ModsDirectory)$(ModName)/%(RecursiveDir)%(Filename)%(Extension)')"
              SkipUnchangedFiles="false" />

        <!-- Copy the project output DLL -->
        <Copy SourceFiles="$(TargetPath)"
              DestinationFolder="$(ModsDirectory)$(ModName)/"
              SkipUnchangedFiles="false" />

        <!-- Copy deps.json to mod output folder if exists -->
        <ItemGroup>
            <_DepsJsonFile Include="$(TargetDir)$(TargetName).deps.json"
                           Condition="Exists('$(TargetDir)$(TargetName).deps.json')" />
        </ItemGroup>
        <Copy SourceFiles="@(_DepsJsonFile)"
              DestinationFolder="$(ModsDirectory)$(ModName)/"
              SkipUnchangedFiles="false"
              Condition="@(_DepsJsonFile) != ''" />

    </Target>

    <Target Name="RemoveIfDeployModFalse" AfterTargets="Build"
            Condition=" '$(DuckovPath)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' == 'false' ">
        <RemoveDir Directories="$(ModsDirectory)$(ModName)" />
    </Target>

    <!-- Pre-build: Extract localization keys from generated metadata to JSON -->
    <Target Name="ExtractLKeysJson" AfterTargets="CoreCompile" BeforeTargets="UpdateLocalesCsv"
            Condition="'$(_ShouldProcessLocalization)' == 'true'">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <_ExtractScriptInProject>$(MSBuildThisFileDirectory)../scripts/extract-lkeys-json.csx</_ExtractScriptInProject>
            <ExtractScriptPath Condition="$([System.IO.File]::Exists('$(_ExtractScriptInProject)'))">$(_ExtractScriptInProject)</ExtractScriptPath>
        </PropertyGroup>

        <ItemGroup Condition="'$(ExtractScriptPath)' == ''">
            <_ExtractLKeysScriptFromContent Include="@(Compile)"
                                            Condition="'%(Filename)%(Extension)' == 'extract-lkeys-json.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <ExtractScriptPath Condition="'$(ExtractScriptPath)' == '' AND '@(_ExtractLKeysScriptFromContent)' != ''">%(_ExtractLKeysScriptFromContent.FullPath)</ExtractScriptPath>
            <!-- Fallback only: allow external override via /p:AssetsDir=... -->
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <LKeysJsonPath>$([System.IO.Path]::Combine('$(AssetsDir)','lkeys.json'))</LKeysJsonPath>
            <!-- 使用 CompilerGeneratedFilesOutputPath，如果未设置则使用 IntermediateOutputPath -->
            <_GeneratedFilesPath Condition="'$(CompilerGeneratedFilesOutputPath)' != ''">$(CompilerGeneratedFilesOutputPath)</_GeneratedFilesPath>
            <_GeneratedFilesPath Condition="'$(_GeneratedFilesPath)' == ''">$(IntermediateOutputPath)</_GeneratedFilesPath>
            <_GeneratedFilesFullPath>$([System.IO.Path]::GetFullPath('$(_GeneratedFilesPath)'))</_GeneratedFilesFullPath>
        </PropertyGroup>

        <Message Text="Extracting localization keys to JSON..." Importance="high"
                 Condition="'$(ExtractScriptPath)' != ''" />
        <Message Text="  Script: $(ExtractScriptPath)" Importance="high" />
        <Message Text="  Generated Files Dir: $(_GeneratedFilesFullPath)" Importance="high" />
        <Message Text="  Output: $(LKeysJsonPath)" Importance="high" />

        <Exec
            Command="dotnet script &quot;$(ExtractScriptPath)&quot; &quot;$(_GeneratedFilesFullPath)&quot; &quot;$(LKeysJsonPath)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="true"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(ExtractScriptPath)' != ''">
            <Output TaskParameter="ConsoleOutput" ItemName="_ExtractJsonOutput" />
            <Output TaskParameter="ExitCode" PropertyName="_ExtractJsonExitCode" />
        </Exec>

        <!-- 退出码说明：
             0 = 成功提取 JSON
             2 = 项目没有本地化键（不是错误）
             其他 = 实际错误 -->
        <Message Text="No localization keys found in this project, skipping CSV generation" Importance="high"
                 Condition="'$(_ExtractJsonExitCode)' == '2'" />

        <Warning Text="Failed to extract localization keys (exit code $(_ExtractJsonExitCode))"
                 Condition="'$(_ExtractJsonExitCode)' != '0' AND '$(_ExtractJsonExitCode)' != '2' AND '$(_ExtractJsonExitCode)' != ''" />

        <Message Text="Localization keys extraction completed successfully" Importance="high"
                 Condition="'$(_ExtractJsonExitCode)' == '0'" />
    </Target>

    <!-- Post-build: Update localization CSV files -->
    <Target Name="UpdateLocalesCsv" AfterTargets="AfterBuild"
            Condition="'$(_ShouldProcessLocalization)' == 'true' AND Exists('$(LKeysJsonPath)')">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <!-- 获取 NuGet 包的安装路径（$(MSBuildThisFileDirectory) 指向 .targets 所在目录，即 build/） -->
            <!-- 假设脚本在包的 tools/ 目录，通过 .. 回退到包根目录再进入 tools -->
            <_ScriptInProject>$(MSBuildThisFileDirectory)../scripts/update-locales-csv.csx</_ScriptInProject>
            <UpdateScriptPath Condition="$([System.IO.File]::Exists('$(_ScriptInProject)'))">$(_ScriptInProject)</UpdateScriptPath>
        </PropertyGroup>

        <ItemGroup Condition="'$(UpdateScriptPath)' == ''">
            <_UpdateLocalesScriptFromContent Include="@(Compile)"
                                             Condition="'%(Filename)%(Extension)' == 'update-locales-csv.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <UpdateScriptPath Condition="'$(UpdateScriptPath)' == '' AND '@(_UpdateLocalesScriptFromContent)' != ''">%(_UpdateLocalesScriptFromContent.FullPath)</UpdateScriptPath>
            <!-- Fallback only: allow external override via /p:AssetsDir=... -->
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <TargetAssembly>$(TargetPath)</TargetAssembly>
        </PropertyGroup>

        <Message Text="Running update-locales-csv.csx via dotnet script..." Importance="high" />
        <Message Text="  ProjectDir: $(ProjectDir)" Importance="high" />
        <Message Text="  AssetsDir Raw: $(AssetsDir)" Importance="high" />
        <Message Text="  TargetAssembly: $(TargetAssembly)" Importance="high" />
        <Message Text="  Script candidate (project): $(_ScriptInProject)" Importance="low" />
        <Message Text="  Script candidate (contentFiles): @(_UpdateLocalesScriptFromContent->'%(FullPath)')"
                 Importance="low" Condition="'@(_UpdateLocalesScriptFromContent)' != ''" />
        <Message Text="  Chosen Script: $(UpdateScriptPath)" Importance="high" Condition="'$(UpdateScriptPath)' != ''" />
        <Warning Text="update-locales-csv.csx not found. Checked: $(_ScriptInProject); contentFiles. Skipping Exec."
                 Condition="'$(UpdateScriptPath)' == ''" />
        <!-- 支持 AssetsDir 以分号分隔的多个目录：展开为 _AssetsDirList 项 -->
        <ItemGroup Condition="'$(AssetsDir)' != ''">
            <!-- 使用 MSBuild 的 Replace 和 Splitting 技巧：先将分号替换为 ;; 再借助 %(Identity) 展开。这里直接利用 @(AssetsDirSplit) 的 Include 逗号/分号分隔特性。 -->
            <_AssetsDirList Include="$(AssetsDir)" />
        </ItemGroup>
        <Message Text="  Resolved AssetsDir Count: @(_AssetsDirList->Count())" Importance="high"
                 Condition="'@(_AssetsDirList)' != ''" />
        <Message Text="  AssetsDir Each: @(_AssetsDirList->'%(Identity)', ' | ')" Importance="high"
                 Condition="'@(_AssetsDirList)' != ''" />
        <!-- 计算每个目录的绝对路径，便于日志观测与排错 -->
        <ItemGroup Condition="'@(_AssetsDirList)' != ''">
            <_AssetsDirResolved
                Include="@(_AssetsDirList->'$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(ProjectDir)','%(Identity)'))))')" />
        </ItemGroup>
        <Message Text="  AssetsDir Absolute Each: @(_AssetsDirResolved->'%(Identity)', ' | ')" Importance="high"
                 Condition="'@(_AssetsDirResolved)' != ''" />
        <Warning Text="AssetsDir empty, skipping update-locales-csv execution." Condition="'$(AssetsDir)' == ''" />
        <!-- 针对每个目录批处理执行脚本 -->
        <Exec
            Command="dotnet script &quot;$(UpdateScriptPath)&quot; &quot;$(ProjectDir)&quot; &quot;%(_AssetsDirList.Identity)&quot; &quot;$(TargetAssembly)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="false"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(UpdateScriptPath)' != '' AND '@(_AssetsDirList)' != ''">
            <Output TaskParameter="ConsoleOutput" ItemName="_LocalesUpdateOutput" />
        </Exec>
        <Message Text="  update-locales-csv outputs: @(_LocalesUpdateOutput->'%(Identity)')" Importance="low"
                 Condition="'@(_LocalesUpdateOutput)' != ''" />
    </Target>

    <!-- 依赖收集逻辑独立为 CollectModDependencies Target -->
    <Target Name="CollectModDependencies">
        <!-- 收集项目输出目录中的所有 DLL 文件（排除项目自身的输出 DLL） -->
        <ItemGroup>
            <_AllOutputDlls Include="$(TargetDir)*.dll" Exclude="$(TargetPath)" />
        </ItemGroup>
        <!-- 收集 ManagedDirectory 中的所有 DLL 文件名（仅文件名，不含路径） -->
        <ItemGroup>
            <_ManagedDlls Include="$(ManagedDirectory)*.dll" />
            <_ManagedDllNames Include="@(_ManagedDlls->'%(Filename)%(Extension)')" />
        </ItemGroup>
        <!-- 分离需要复制和可合并的 DLL -->
        <ItemGroup>
            <_DllsToCopy Include="@(_AllOutputDlls)"
                         Condition=" !@(_ManagedDllNames->AnyHaveMetadataValue('Identity', '%(Filename)%(Extension)')) " />
            <_DllsToPack Include="@(_AllOutputDlls)" />
        </ItemGroup>
    </Target>

    <!-- 复制项目输出目录中不在 ManagedDirectory 的所有 DLL 到 Mod 的 Dependency 文件夹 -->
    <Target Name="CopyMissingDependencies" AfterTargets="Build"
            DependsOnTargets="CollectModDependencies"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' ">
        <PropertyGroup>
            <_DestDir>$(ModsDirectory)$(ModName)/Dependency/</_DestDir>
        </PropertyGroup>
        <Message Text="[CopyMissingDependencies] Found @(_DllsToCopy->Count()) DLL(s) to copy" Importance="High" />
        <MakeDir Directories="$(_DestDir)" Condition=" '@(_DllsToCopy)' != '' " />
        <Copy SourceFiles="@(_DllsToCopy)"
              DestinationFolder="$(_DestDir)"
              SkipUnchangedFiles="false"
              OverwriteReadOnlyFiles="true"
              Condition=" '@(_DllsToCopy)' != '' ">
            <Output TaskParameter="CopiedFiles" ItemName="_CopiedDependencies" />
        </Copy>
        <Message
            Text="[CopyMissingDependencies] Copied @(_CopiedDependencies->Count()) DLL(s) to Dependency folder: @(_CopiedDependencies->'%(Filename)%(Extension)', ', ')"
            Importance="High"
            Condition="@(_CopiedDependencies) != ''" />
        <Message Text="[CopyMissingDependencies] No dependencies to copy"
                 Importance="High"
                 Condition="@(_CopiedDependencies) == '' AND @(_DllsToCopy) == ''" />
    </Target>

    <!-- 新增 PackModWithILRepack Target，合并主 DLL 和依赖项 -->
    <Target Name="PackModWithILRepack" AfterTargets="Build"
            DependsOnTargets="CollectModDependencies"
            Condition=" '$(EnableILRepack)' == 'true' AND '$(DuckovFolder)' != '' AND '$(ModName)' != '' ">
        <PropertyGroup>
            <_FinalModDll>$(ModsDirectory)$(ModName)/$(ModName).dll</_FinalModDll>
            <_TempPackedDll>$(ModsDirectory)$(ModName)/$(ModName).packed.tmp.dll</_TempPackedDll>
            <!-- 构建带引号的依赖 DLL 列表 -->
            <_DllsToPackList>@(_DllsToPack->'&quot;%(FullPath)&quot;', ' ')</_DllsToPackList>
        </PropertyGroup>

        <MakeDir Directories="$(ModsDirectory)$(ModName)" />

        <!-- 收集所有可能包含依赖项的目录 -->
        <ItemGroup>
            <!-- 1. 项目输出目录（包含所有复制的依赖项） -->
            <_ILRepackLibDirs Include="$(TargetDir)" />
            <!-- 2. ManagedDirectory（游戏的托管程序集） -->
            <_ILRepackLibDirs Include="$(ManagedDirectory)"
                              Condition=" '$(ManagedDirectory)' != '' AND Exists('$(ManagedDirectory)') " />
            <!-- 3. 收集所有引用程序集的目录（去重） -->
            <_ILRepackLibDirs Include="@(ReferencePath->'%(RootDir)%(Directory)')" />
            <!-- 4. NuGet 包的运行时程序集目录 -->
            <_ILRepackLibDirs Include="@(RuntimeCopyLocalItems->'%(RootDir)%(Directory)')" />
        </ItemGroup>

        <!-- 去重并构建 /lib 参数列表 -->
        <RemoveDuplicates Inputs="@(_ILRepackLibDirs)">
            <Output TaskParameter="Filtered" ItemName="_UniqueLibDirs" />
        </RemoveDuplicates>

        <PropertyGroup>
            <!-- 构建 /lib 参数：每个目录添加 /lib:"path" -->
            <_LibPathArgs>@(_UniqueLibDirs->'/lib:&quot;%(Identity)&quot;', ' ')</_LibPathArgs>
        </PropertyGroup>

        <Message Text="[PackModWithILRepack] Merging mod DLL and dependencies into $(_FinalModDll)" Importance="High" />
        <Message Text="[PackModWithILRepack] Primary DLL: $(TargetPath)" Importance="High" />
        <Message Text="[PackModWithILRepack] Dependencies to merge: @(_DllsToPack->'%(Filename)%(Extension)', ', ')"
                 Importance="High" />
        <Message Text="[PackModWithILRepack] Library search paths (@(_UniqueLibDirs->Count()) directories):"
                 Importance="High" />
        <Message Text="  - %(_UniqueLibDirs.Identity)" Importance="High" />
        <Message Text="[PackModWithILRepack] Generated lib args: $(_LibPathArgs)" Importance="High" />

        <!-- 先输出到临时文件，使用收集的所有 lib 路径 -->
        <Exec
            Command="ilrepack /out:&quot;$(_TempPackedDll)&quot; &quot;$(TargetPath)&quot; $(_DllsToPackList) /internalize /wildcards /log /verbose $(_LibPathArgs)" />

        <!-- 用临时文件覆盖原文件 -->
        <Copy SourceFiles="$(_TempPackedDll)" DestinationFiles="$(_FinalModDll)" OverwriteReadOnlyFiles="true" />
        <Message Text="[PackModWithILRepack] Successfully merged all assemblies into $(_FinalModDll)" Importance="High" />

        <!-- 删除临时文件 -->
        <Delete Files="$(_TempPackedDll)" />
    </Target>
</Project>
