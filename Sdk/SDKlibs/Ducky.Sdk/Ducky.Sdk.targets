<Project>
    <!-- Validation: At least one of DuckovFolder or SteamFolder must be set -->
    <Target Name="ValidateDuckovFolder" BeforeTargets="BeforeBuild">
        <Error Condition=" '$(DuckovFolder)' == '' AND '$(SteamFolder)' == '' "
               Text="Either DuckovFolder or SteamFolder must be specified. Please set one of them in your project or Local.props file." />
    </Target>

    <Target Name="CopyToDuckov" AfterTargets="Build"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' ">
        <!-- Ensure destination folder exists -->
        <MakeDir Directories="$(ModsDirectory)$(ModName)" />

        <!-- copy preview.png and info.ini -->
        <Copy SourceFiles="@(AssetsFiles)"
              DestinationFiles="@(AssetsFiles->'$(ModsDirectory)$(ModName)/%(RecursiveDir)%(Filename)%(Extension)')"
              SkipUnchangedFiles="false" />

        <!-- copy description.md if exists -->
        <Copy SourceFiles="@(DescriptionMd)"
              DestinationFiles="@(DescriptionMd->'$(ModsDirectory)$(ModName)/description.md')"
              SkipUnchangedFiles="false" />

        <!-- copy preview.png if exists -->
        <Copy SourceFiles="@(PreviewPng)"
              DestinationFiles="@(PreviewPng->'$(ModsDirectory)$(ModName)/preview.png')"
              SkipUnchangedFiles="false" />

        <!-- Copy the project output DLL -->
        <Copy SourceFiles="$(TargetPath)"
              DestinationFolder="$(ModsDirectory)$(ModName)/"
              SkipUnchangedFiles="false" />

    </Target>

    <Target Name="RemoveIfDeployModFalse" AfterTargets="Build"
            Condition=" '$(DuckovPath)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' == 'false' ">
        <RemoveDir Directories="$(ModsDirectory)$(ModName)" />
    </Target>

    <!-- Pre-build: Extract localization keys from generated metadata to JSON -->
    <Target Name="ExtractLKeysJson" AfterTargets="CoreCompile" BeforeTargets="UpdateLocalesCsv"
            Condition="'$(_ShouldProcessLocalization)' == 'true'">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <_ExtractScriptInProject>$(MSBuildThisFileDirectory)../scripts/extract-lkeys-json.csx</_ExtractScriptInProject>
            <ExtractScriptPath Condition="$([System.IO.File]::Exists('$(_ExtractScriptInProject)'))">$(_ExtractScriptInProject)</ExtractScriptPath>
        </PropertyGroup>

        <ItemGroup Condition="'$(ExtractScriptPath)' == ''">
            <_ExtractLKeysScriptFromContent Include="@(Compile)"
                                            Condition="'%(Filename)%(Extension)' == 'extract-lkeys-json.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <ExtractScriptPath Condition="'$(ExtractScriptPath)' == '' AND '@(_ExtractLKeysScriptFromContent)' != ''">%(_ExtractLKeysScriptFromContent.FullPath)</ExtractScriptPath>
            <!-- Fallback only: allow external override via /p:AssetsDir=... -->
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <LKeysJsonPath>$([System.IO.Path]::Combine('$(AssetsDir)','lkeys.json'))</LKeysJsonPath>
            <!-- 使用 CompilerGeneratedFilesOutputPath，如果未设置则使用 IntermediateOutputPath -->
            <_GeneratedFilesPath Condition="'$(CompilerGeneratedFilesOutputPath)' != ''">$(CompilerGeneratedFilesOutputPath)</_GeneratedFilesPath>
            <_GeneratedFilesPath Condition="'$(_GeneratedFilesPath)' == ''">$(IntermediateOutputPath)</_GeneratedFilesPath>
            <_GeneratedFilesFullPath>$([System.IO.Path]::GetFullPath('$(_GeneratedFilesPath)'))</_GeneratedFilesFullPath>
        </PropertyGroup>

        <Message Text="Extracting localization keys to JSON..." Importance="high"
                 Condition="'$(ExtractScriptPath)' != ''" />
        <Message Text="  Script: $(ExtractScriptPath)" Importance="high" />
        <Message Text="  Generated Files Dir: $(_GeneratedFilesFullPath)" Importance="high" />
        <Message Text="  Output: $(LKeysJsonPath)" Importance="high" />

        <Exec
            Command="dotnet script &quot;$(ExtractScriptPath)&quot; &quot;$(_GeneratedFilesFullPath)&quot; &quot;$(LKeysJsonPath)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="true"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(ExtractScriptPath)' != ''">
            <Output TaskParameter="ConsoleOutput" ItemName="_ExtractJsonOutput" />
            <Output TaskParameter="ExitCode" PropertyName="_ExtractJsonExitCode" />
        </Exec>

        <!-- 退出码说明：
             0 = 成功提取 JSON
             2 = 项目没有本地化键（不是错误）
             其他 = 实际错误 -->
        <Message Text="No localization keys found in this project, skipping CSV generation" Importance="high"
                 Condition="'$(_ExtractJsonExitCode)' == '2'" />

        <Warning Text="Failed to extract localization keys (exit code $(_ExtractJsonExitCode))"
                 Condition="'$(_ExtractJsonExitCode)' != '0' AND '$(_ExtractJsonExitCode)' != '2' AND '$(_ExtractJsonExitCode)' != ''" />

        <Message Text="Localization keys extraction completed successfully" Importance="high"
                 Condition="'$(_ExtractJsonExitCode)' == '0'" />
    </Target>

    <!-- Post-build: Update localization CSV files -->
    <Target Name="UpdateLocalesCsv" AfterTargets="AfterBuild"
            Condition="'$(_ShouldProcessLocalization)' == 'true' AND Exists('$(LKeysJsonPath)')">
        <PropertyGroup>
            <ProjectDir>$([System.IO.Path]::GetDirectoryName('$(MSBuildProjectFullPath)'))</ProjectDir>
            <!-- 获取 NuGet 包的安装路径（$(MSBuildThisFileDirectory) 指向 .targets 所在目录，即 build/） -->
            <!-- 假设脚本在包的 tools/ 目录，通过 .. 回退到包根目录再进入 tools -->
            <_ScriptInProject>$(MSBuildThisFileDirectory)../scripts/update-locales-csv.csx</_ScriptInProject>
            <UpdateScriptPath Condition="$([System.IO.File]::Exists('$(_ScriptInProject)'))">$(_ScriptInProject)</UpdateScriptPath>
        </PropertyGroup>

        <ItemGroup Condition="'$(UpdateScriptPath)' == ''">
            <_UpdateLocalesScriptFromContent Include="@(Compile)"
                                             Condition="'%(Filename)%(Extension)' == 'update-locales-csv.csx'" />
        </ItemGroup>

        <PropertyGroup>
            <UpdateScriptPath Condition="'$(UpdateScriptPath)' == '' AND '@(_UpdateLocalesScriptFromContent)' != ''">%(_UpdateLocalesScriptFromContent.FullPath)</UpdateScriptPath>
            <!-- Fallback only: allow external override via /p:AssetsDir=... -->
            <AssetsDir Condition="'$(AssetsDir)' == ''">$([System.IO.Path]::Combine('$(ProjectDir)','assets'))</AssetsDir>
            <TargetAssembly>$(TargetPath)</TargetAssembly>
        </PropertyGroup>

        <Message Text="Running update-locales-csv.csx via dotnet script..." Importance="high" />
        <Message Text="  ProjectDir: $(ProjectDir)" Importance="high" />
        <Message Text="  AssetsDir Raw: $(AssetsDir)" Importance="high" />
        <Message Text="  TargetAssembly: $(TargetAssembly)" Importance="high" />
        <Message Text="  Script candidate (project): $(_ScriptInProject)" Importance="low" />
        <Message Text="  Script candidate (contentFiles): @(_UpdateLocalesScriptFromContent->'%(FullPath)')"
                 Importance="low" Condition="'@(_UpdateLocalesScriptFromContent)' != ''" />
        <Message Text="  Chosen Script: $(UpdateScriptPath)" Importance="high" Condition="'$(UpdateScriptPath)' != ''" />
        <Warning Text="update-locales-csv.csx not found. Checked: $(_ScriptInProject); contentFiles. Skipping Exec."
                 Condition="'$(UpdateScriptPath)' == ''" />
        <!-- 支持 AssetsDir 以分号分隔的多个目录：展开为 _AssetsDirList 项 -->
        <ItemGroup Condition="'$(AssetsDir)' != ''">
            <!-- 使用 MSBuild 的 Replace 和 Splitting 技巧：先将分号替换为 ;; 再借助 %(Identity) 展开。这里直接利用 @(AssetsDirSplit) 的 Include 逗号/分号分隔特性。 -->
            <_AssetsDirList Include="$(AssetsDir)" />
        </ItemGroup>
        <Message Text="  Resolved AssetsDir Count: @(_AssetsDirList->Count())" Importance="high"
                 Condition="'@(_AssetsDirList)' != ''" />
        <Message Text="  AssetsDir Each: @(_AssetsDirList->'%(Identity)', ' | ')" Importance="high"
                 Condition="'@(_AssetsDirList)' != ''" />
        <!-- 计算每个目录的绝对路径，便于日志观测与排错 -->
        <ItemGroup Condition="'@(_AssetsDirList)' != ''">
            <_AssetsDirResolved
                Include="@(_AssetsDirList->'$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(ProjectDir)','%(Identity)'))))')" />
        </ItemGroup>
        <Message Text="  AssetsDir Absolute Each: @(_AssetsDirResolved->'%(Identity)', ' | ')" Importance="high"
                 Condition="'@(_AssetsDirResolved)' != ''" />
        <Warning Text="AssetsDir empty, skipping update-locales-csv execution." Condition="'$(AssetsDir)' == ''" />
        <!-- 针对每个目录批处理执行脚本 -->
        <Exec
            Command="dotnet script &quot;$(UpdateScriptPath)&quot; &quot;$(ProjectDir)&quot; &quot;%(_AssetsDirList.Identity)&quot; &quot;$(TargetAssembly)&quot;"
            ContinueOnError="true"
            IgnoreExitCode="false"
            WorkingDirectory="$(MSBuildProjectDirectory)"
            Condition="'$(UpdateScriptPath)' != '' AND '@(_AssetsDirList)' != ''">
            <Output TaskParameter="ConsoleOutput" ItemName="_LocalesUpdateOutput" />
        </Exec>
        <Message Text="  update-locales-csv outputs: @(_LocalesUpdateOutput->'%(Identity)')" Importance="low"
                 Condition="'@(_LocalesUpdateOutput)' != ''" />
    </Target>

    <!-- 复制项目输出目录中不在 ManagedDirectory 的所有 DLL 到 Mod 的 Dependency 文件夹 -->
    <Target Name="CopyMissingDependencies" AfterTargets="Build"
            Condition=" '$(DuckovFolder)' != '' AND '$(ModName)' != '' AND '$(DeployMod)' != 'false' ">
        <!-- 目标目录：Mod 的 Dependency 子文件夹 -->
        <PropertyGroup>
            <_DestDir>$(ModsDirectory)$(ModName)/Dependency/</_DestDir>
        </PropertyGroup>

        <!-- 收集项目输出目录中的所有 DLL 文件（排除项目自身的输出 DLL） -->
        <ItemGroup>
            <_AllOutputDlls Include="$(TargetDir)*.dll" Exclude="$(TargetPath)" />
        </ItemGroup>

        <Message Text="[CopyMissingDependencies] Found @(_AllOutputDlls->Count()) DLL(s) in output directory"
                 Importance="High" />

        <!-- 收集 ManagedDirectory 中的所有 DLL 文件名（仅文件名，不含路径） -->
        <ItemGroup>
            <_ManagedDlls Include="$(ManagedDirectory)*.dll" />
            <_ManagedDllNames Include="@(_ManagedDlls->'%(Filename)%(Extension)')" />
        </ItemGroup>

        <Message Text="[CopyMissingDependencies] ManagedDirectory: $(ManagedDirectory)"
                 Importance="High" />
        <Message Text="[CopyMissingDependencies] Found @(_ManagedDlls->Count()) DLL(s) in ManagedDirectory"
                 Importance="High" />

        <!-- 分离需要复制的 DLL 和已存在的 DLL -->
        <ItemGroup>
            <!-- 检查每个输出 DLL 是否在 ManagedDirectory 中存在 -->
            <_DllsToCopy Include="@(_AllOutputDlls)"
                         Condition=" !@(_ManagedDllNames->AnyHaveMetadataValue('Identity', '%(Filename)%(Extension)')) " />
            <_SkippedDlls Include="@(_AllOutputDlls)"
                          Condition=" @(_ManagedDllNames->AnyHaveMetadataValue('Identity', '%(Filename)%(Extension)')) " />
        </ItemGroup>

        <!-- 输出警告：跳过已在 ManagedDirectory 中存在的 DLL -->
        <Warning
            Text="[CopyMissingDependencies] Skipping '%(Filename)%(Extension)' - already exists in ManagedDirectory"
            Condition=" '@(_SkippedDlls)' != '' " />

        <!-- 创建目标目录 -->
        <MakeDir Directories="$(_DestDir)" Condition=" '@(_DllsToCopy)' != '' " />

        <!-- 复制不在 ManagedDirectory 中的 DLL -->
        <Copy SourceFiles="@(_DllsToCopy)"
              DestinationFolder="$(_DestDir)"
              SkipUnchangedFiles="false"
              OverwriteReadOnlyFiles="true"
              Condition=" '@(_DllsToCopy)' != '' ">
            <Output TaskParameter="CopiedFiles" ItemName="_CopiedDependencies" />
        </Copy>

        <Message
            Text="[CopyMissingDependencies] Copied @(_CopiedDependencies->Count()) DLL(s) to Dependency folder: @(_CopiedDependencies->'%(Filename)%(Extension)', ', ')"
            Importance="High"
            Condition="@(_CopiedDependencies) != ''" />

        <Message Text="[CopyMissingDependencies] No dependencies to copy"
                 Importance="High"
                 Condition="@(_CopiedDependencies) == '' AND @(_DllsToCopy) == ''" />
    </Target>
</Project>
