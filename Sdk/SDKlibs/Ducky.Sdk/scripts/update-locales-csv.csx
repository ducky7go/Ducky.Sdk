// NOTE: Nullable reference types disabled for dotnet-script compatibility; removing nullable annotations.
#nullable disable
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;

// Usage: dotnet script update-locales-csv.csx <ProjectDir> <AssetsDir> <TargetAssembly>
// Robust Args resolution: find args after the .csx script path
List<string> GetScriptArgs()
{
    var all = Environment.GetCommandLineArgs();
    var idx = Array.FindIndex(all, s => s.EndsWith(".csx", StringComparison.OrdinalIgnoreCase));
    if (idx >= 0 && idx + 1 < all.Length)
    {
        return all.Skip(idx + 1).ToList();
    }
    // Fallback: best effort (may include host exe at [0])
    return all.Skip(1).ToList();
}
var Args = GetScriptArgs();
if (Args == null || Args.Count < 3)
{
    Console.Error.WriteLine("Usage: update-locales-csv.csx <ProjectDir> <AssetsDir> <TargetAssembly>");
    return 1;
}

var projectDir = Args[0];
var assetsDir = Args[1];
var targetAssembly = Args[2];

// locales directory will be resolved from assetsDir below
string localesDir = string.Empty;

Console.WriteLine($"Running update-locales-csv.csx\n  ProjectDir: {projectDir}\n  AssetsDir: {assetsDir}\n  TargetAssembly: {targetAssembly}");

if (!File.Exists(targetAssembly))
{
    Console.WriteLine($"Warning: Target assembly not found: {targetAssembly}");
    return 0;
}

List<string> keys = new();
Dictionary<string, string> keyFileExtensions = new(); // key -> file extension
List<string> supportedLanguages = null; // will populate if attribute exists

// 从 JSON 文件读取 keys
var jsonKeyFile = Path.Combine(assetsDir, "lkeys.json");

if (!File.Exists(jsonKeyFile))
{
    Console.Error.WriteLine($"Error: lkeys.json file not found at: {jsonKeyFile}");
    Console.Error.WriteLine("The JSON file should be generated by the Source Generator during build.");
    return 1;
}

try
{
    Console.WriteLine($"Reading keys from: {jsonKeyFile}");
    var jsonContent = File.ReadAllText(jsonKeyFile);
    using var doc = System.Text.Json.JsonDocument.Parse(jsonContent);
    var root = doc.RootElement;
    
    // Read supported languages if present
    if (root.TryGetProperty("supportedLanguages", out var langsArray))
    {
        supportedLanguages = new List<string>();
        foreach (var langElement in langsArray.EnumerateArray())
        {
            var lang = langElement.GetString();
            if (!string.IsNullOrWhiteSpace(lang))
            {
                supportedLanguages.Add(lang.ToLowerInvariant());
            }
        }
        Console.WriteLine($"Found {supportedLanguages.Count} supported languages: {string.Join(", ", supportedLanguages)}");
    }
    
    if (root.TryGetProperty("keys", out var keysArray))
    {
        foreach (var keyElement in keysArray.EnumerateArray())
        {
            if (keyElement.ValueKind == System.Text.Json.JsonValueKind.String)
            {
                // Simple string key
                var key = keyElement.GetString();
                if (!string.IsNullOrWhiteSpace(key))
                {
                    keys.Add(key);
                }
            }
            else if (keyElement.ValueKind == System.Text.Json.JsonValueKind.Object)
            {
                // Key with file extension
                if (keyElement.TryGetProperty("key", out var keyProp))
                {
                    var key = keyProp.GetString();
                    if (!string.IsNullOrWhiteSpace(key))
                    {
                        keys.Add(key);
                        
                        if (keyElement.TryGetProperty("fileExtension", out var extProp))
                        {
                            var ext = extProp.GetString();
                            if (!string.IsNullOrWhiteSpace(ext))
                            {
                                keyFileExtensions[key] = ext;
                                Console.WriteLine($"  Key '{key}' marked as file reference with extension '.{ext}'");
                            }
                        }
                    }
                }
            }
        }
        
        Console.WriteLine($"Loaded {keys.Count} keys from JSON file ({keyFileExtensions.Count} with file references)");
    }
    else
    {
        Console.Error.WriteLine("Error: 'keys' property not found in JSON file");
        return 1;
    }
}
catch (Exception ex)
{
    Console.Error.WriteLine($"Error: Failed to read or parse JSON file: {ex.Message}");
    return 1;
}

if (keys.Count == 0)
{
    Console.WriteLine("Warning: No keys found in JSON file. Skipping CSV generation.");
    return 0;
}

var distinctKeys = keys.Distinct().OrderBy(k => k).ToList();

string JoinKeys(IEnumerable<string> ks) => string.Join('|', ks);

// Compute CRC32 using internal implementation (no NuGet dependency)
string ComputeCrc32Hex(string input)
{
    var table = MakeCrc32Table();
    uint crc = 0xFFFFFFFFu;
    var b = Encoding.UTF8.GetBytes(input ?? string.Empty);
    foreach (var by in b)
    {
        var idx = (byte)((crc ^ by) & 0xFF);
        crc = (crc >> 8) ^ table[idx];
    }
    crc ^= 0xFFFFFFFFu;
    return crc.ToString("x8");
}

static uint[] MakeCrc32Table()
{
    uint[] table = new uint[256];
    const uint poly = 0xEDB88320u;
    for (uint i = 0; i < 256; i++)
    {
        uint crc = i;
        for (int j = 0; j < 8; j++)
        {
            if ((crc & 1) != 0)
                crc = (crc >> 1) ^ poly;
            else
                crc >>= 1;
        }
        table[i] = crc;
    }
    return table;
}

var allKeysJoined = JoinKeys(distinctKeys);
var assemblyHash = ComputeCrc32Hex(allKeysJoined);

Console.WriteLine($"Found hash: {assemblyHash}");
Console.WriteLine($"Found {distinctKeys.Count} unique keys");

var hashFile = Path.Combine(assetsDir, "keys.hash.txt");

// If the caller passed the project assets folder or the Locales folder, choose the correct Locales path.
// Behavior:
// - If the provided assetsDir already points to a folder named 'Locales', use it.
// - Else, if assetsDir/Locales exists, use that.
// - Else, if assetsDir itself contains CSV files, use assetsDir (legacy layout).
// - Otherwise use assetsDir/Locales (will be created later when writing files).
{
    var providedAssets = assetsDir; // original passed assetsDir
    string chosen;
    try
    {
        var providedInfo = new DirectoryInfo(providedAssets);
        var providedName = providedInfo.Name ?? string.Empty;
        if (string.Equals(providedName, "Locales", StringComparison.OrdinalIgnoreCase) && providedInfo.Exists)
        {
            chosen = providedInfo.FullName; // caller already pointed to Locales
        }
        else
        {
            var candidate = Path.Combine(providedAssets, "Locales");
            if (Directory.Exists(candidate))
            {
                chosen = Path.GetFullPath(candidate); // typical assets/Locales exists
            }
            else if (providedInfo.Exists && Directory.GetFiles(providedAssets, "*.csv", SearchOption.TopDirectoryOnly).Any())
            {
                chosen = Path.GetFullPath(providedAssets); // assets dir itself holds CSVs
            }
            else
            {
                chosen = Path.GetFullPath(candidate); // fallback: use assets/Locales (may be created)
            }
        }
    }
    catch (Exception)
    {
        // In case of any path/IO issues, fallback to assets/Locales
        chosen = Path.GetFullPath(Path.Combine(providedAssets, "Locales"));
    }

    // Normalize and assign
    try
    {
        var prev = string.IsNullOrWhiteSpace(localesDir) ? string.Empty : Path.GetFullPath(localesDir);
        var curr = Path.GetFullPath(chosen);
        if (!string.Equals(prev, curr, StringComparison.OrdinalIgnoreCase))
        {
            Console.WriteLine($"Note: resolved Locales directory to: {curr}");
        }
        localesDir = curr;
    }
    catch
    {
        localesDir = chosen;
    }
}

// Determine language entries based on LanguageSupport attribute or existing files
var languageEntries = new List<(string LangCode, string CsvPath, string LangDir)>();

if (supportedLanguages != null && supportedLanguages.Count > 0)
{
    // Use specified languages from LanguageSupport attribute
    Console.WriteLine($"Using languages specified in LanguageSupport attribute: {string.Join(", ", supportedLanguages)}");
    foreach (var langCode in supportedLanguages)
    {
        var csvPath = Path.Combine(localesDir, langCode + ".csv");
        var langDir = Path.Combine(localesDir, langCode);
        languageEntries.Add((langCode, csvPath, langDir));
    }
}
else if (Directory.Exists(localesDir))
{
    // Fallback: discover from existing files
    Console.WriteLine("No LanguageSupport attribute found, discovering languages from existing files...");
    
    // Look for CSV files directly under localesDir
    var csvFilesRoot = Directory.GetFiles(localesDir, "*.csv", SearchOption.TopDirectoryOnly);
    if (csvFilesRoot.Length > 0)
    {
        foreach (var csv in csvFilesRoot)
        {
            var code = Path.GetFileNameWithoutExtension(csv);
            // Even if discovered from root CSVs, create/use a language subdirectory to hold file-based translations
            var langDirCandidate = Path.Combine(localesDir, code);
            languageEntries.Add((code, csv, langDirCandidate));
        }
    }

    // Also consider language subdirectories as languages if present
    var subdirs = Directory.GetDirectories(localesDir, "*", SearchOption.TopDirectoryOnly);
    foreach (var sd in subdirs)
    {
        var code = Path.GetFileName(sd);
        var csvPath = Path.Combine(localesDir, code + ".csv");
        // If we already have an entry for this code from root CSV, prefer the root CSV entry (avoid duplication)
        if (!languageEntries.Any(e => string.Equals(e.LangCode, code, StringComparison.OrdinalIgnoreCase)))
        {
            languageEntries.Add((code, csvPath, sd));
        }
    }
}
else
{
    // No existing files and no LanguageSupport attribute - default to English and Chinese
    Console.WriteLine("No existing Locales directory and no LanguageSupport attribute, defaulting to: en, zh");
    var csvPathEn = Path.Combine(localesDir, "en.csv");
    var langDirEn = Path.Combine(localesDir, "en");
    languageEntries.Add(("en", csvPathEn, langDirEn));

    var csvPathZh = Path.Combine(localesDir, "zh.csv");
    var langDirZh = Path.Combine(localesDir, "zh");
    languageEntries.Add(("zh", csvPathZh, langDirZh));
}

// Pre-scan language entries to determine if any CSV is missing or empty
bool needUpdateForMissing = false;
foreach (var entry in languageEntries)
{
    if (!File.Exists(entry.CsvPath) || new FileInfo(entry.CsvPath).Length == 0)
    {
        needUpdateForMissing = true;
        break;
    }
}

// Additional check: detect obsolete keys present in existing CSVs that are not in distinctKeys.
// If found, force an update so obsolete keys will be removed.
int obsoleteKeysDetected = 0;
var obsoletePerFile = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
if (Directory.Exists(localesDir))
{
    var keySet = new HashSet<string>(distinctKeys, StringComparer.Ordinal);
    // Scan all CSVs under localesDir recursively to find any obsolete entries
    foreach (var csvFile in Directory.GetFiles(localesDir, "*.csv", SearchOption.AllDirectories))
    {
        try
        {
            var lines = File.ReadAllLines(csvFile);
            int fileObsolete = 0;
            foreach (var line in lines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                if (line.Trim().Equals("Key,Value", StringComparison.OrdinalIgnoreCase)) continue;
                var idx = line.IndexOf(',');
                if (idx < 0) continue;
                var existingKey = line.Substring(0, idx);
                if (!keySet.Contains(existingKey))
                {
                    fileObsolete++;
                }
            }
            if (fileObsolete > 0)
            {
                obsoletePerFile[Path.GetFileName(csvFile)] = fileObsolete;
                obsoleteKeysDetected += fileObsolete;
                needUpdateForMissing = true;
                Console.WriteLine($"Detected {fileObsolete} obsolete key(s) in {Path.GetFileName(csvFile)}");
            }
        }
        catch (Exception ex)
        {
            // ignore parse errors and continue
            Console.WriteLine($"Warning: could not read CSV {csvFile}: {ex.Message}");
        }
    }
}

if (File.Exists(hashFile))
{
    var existingHash = File.ReadAllText(hashFile).Trim();
    if (existingHash == assemblyHash && !needUpdateForMissing)
    {
        Console.WriteLine("Hash matches existing hash file and all CSVs exist; skipping CSV updates.");
        // Print minimal stats
        Console.WriteLine($"Stats: languages=0, csvsUpdated=0, totalKeys={distinctKeys.Count}, obsoleteKeysDetected=0, standaloneFilesIncluded=0, totalRowsWritten=0");
        return 0;
    }
}

// Ensure locales dir exists
if (!Directory.Exists(localesDir)) Directory.CreateDirectory(localesDir);

// Stats counters
int languagesProcessed = 0;
int csvsUpdated = 0;
int totalStandaloneFilesIncluded = 0;
int totalRowsWritten = 0;
int totalKeys = distinctKeys.Count;

// If no language entries were found, there's nothing to process
if (languageEntries.Count == 0)
{
    Console.WriteLine("No language CSVs or language directories found under localesDir; nothing to update.");
}

// Process each language entry
foreach (var entry in languageEntries)
{
    var langCode = entry.LangCode;
    var csvPath = entry.CsvPath;
    var langDir = entry.LangDir;

    Console.WriteLine($"Processing language: {langCode}");
    languagesProcessed++;

    var csvMap = new Dictionary<string, string>();
    if (File.Exists(csvPath))
    {
        var lines = File.ReadAllLines(csvPath);
        foreach (var line in lines)
        {
            if (string.IsNullOrWhiteSpace(line)) continue;
            if (line.Trim().Equals("Key,Value", StringComparison.OrdinalIgnoreCase)) continue;
            // split on first comma
            var idx = line.IndexOf(',');
            if (idx < 0) continue;
            var key = line.Substring(0, idx);
            var value = line.Substring(idx + 1);
            if (value.Length >= 2 && value[0] == '"' && value[^1] == '"')
            {
                value = value.Substring(1, value.Length - 2).Replace("\"\"" , '"'.ToString());
            }
            value = value.Replace("\"\"" , '"'.ToString());
            csvMap[key] = value;
        }
    }

    // Include standalone md/txt files in the lang folder (only if langDir is present)
    var localStandaloneCount = 0;
    if (!string.IsNullOrEmpty(langDir) && Directory.Exists(langDir))
    {
        var mdFiles = Directory.GetFiles(langDir, "*.md");
        var txtFiles = Directory.GetFiles(langDir, "*.txt");
        foreach (var f in mdFiles.Concat(txtFiles))
        {
            var filename = Path.GetFileName(f);
            var key = Path.GetFileNameWithoutExtension(f);
            csvMap[key] = filename;
            localStandaloneCount++;
            Console.WriteLine($"  Including standalone key in CSV with value=filename: {key} -> {filename}");
        }
    }
    totalStandaloneFilesIncluded += localStandaloneCount;

    // Ensure language directory exists for file references (create it proactively)
    if (!string.IsNullOrEmpty(langDir))
    {
        Directory.CreateDirectory(langDir);
        Console.WriteLine($"  Ensured language directory exists: {langDir}");
    }

    var newRows = new List<(string Key, string Value)>();
    var filesCreated = 0;
    
    foreach (var key in distinctKeys)
    {
        csvMap.TryGetValue(key, out var val);
        
        // Check if this key should use a file reference
        if (keyFileExtensions.TryGetValue(key, out var fileExt))
        {
            // Use the key itself as filename (not the id)
            var fileName = $"{key}.{fileExt}";
            
            // Create the file in the language directory
            if (!string.IsNullOrEmpty(langDir))
            {
                var filePath = Path.Combine(langDir, fileName);
                
                // Only create file if it doesn't exist (preserve manual edits)
                if (!File.Exists(filePath))
                {
                    // Create with default content (the key itself as placeholder)
                    File.WriteAllText(filePath, val ?? key, new UTF8Encoding(false));
                    filesCreated++;
                    Console.WriteLine($"  Created translation file: {fileName}");
                }
                else
                {
                    Console.WriteLine($"  Translation file already exists (preserved): {fileName}");
                }
            }
            
            // In CSV, store the filename as the value
            newRows.Add((key, fileName));
        }
        else
        {
            // Normal string value
            newRows.Add((key, val ?? string.Empty));
        }
    }

    var sorted = newRows.OrderBy(r => r.Key, StringComparer.Ordinal).ToList();

    // Prepare new content and compare to existing to know whether we actually changed the file
    var sbNew = new StringBuilder();
    sbNew.AppendLine("Key,Value");
    foreach (var r in sorted)
    {
        var v = r.Value?.Replace("\"", "\"\"") ?? string.Empty;
        sbNew.AppendLine($"{r.Key},\"{v}\"");
    }
    var newContent = sbNew.ToString();
    var oldContent = File.Exists(csvPath) ? File.ReadAllText(csvPath) : string.Empty;

    if (!string.Equals(newContent, oldContent, StringComparison.Ordinal))
    {
        // Write CSV
        Directory.CreateDirectory(Path.GetDirectoryName(csvPath) ?? localesDir);
        File.WriteAllText(csvPath, newContent, new UTF8Encoding(false));
        csvsUpdated++;
        totalRowsWritten += sorted.Count;
        Console.WriteLine($"  Updated {csvPath} ({sorted.Count} keys, {filesCreated} files created)");
    }
    else
    {
        // No changes to CSV but may have created files
        if (filesCreated > 0)
        {
            Console.WriteLine($"  No changes to {csvPath} but created {filesCreated} translation file(s)");
        }
        else
        {
            Console.WriteLine($"  No changes for {csvPath} ({sorted.Count} keys)");
        }
    }
}

// Save hash
Directory.CreateDirectory(assetsDir);
File.WriteAllText(hashFile, assemblyHash);
Console.WriteLine($"Saved hash to: {hashFile}");
Console.WriteLine("Update completed successfully");

// Print stats summary
Console.WriteLine("--- Update stats ---");
Console.WriteLine($"Languages processed: {languagesProcessed}");
Console.WriteLine($"CSVs updated:        {csvsUpdated}");
Console.WriteLine($"Total keys:          {totalKeys}");
Console.WriteLine($"Obsolete keys found: {obsoleteKeysDetected}");
Console.WriteLine($"Standalone files:    {totalStandaloneFilesIncluded}");
Console.WriteLine($"Total rows written:  {totalRowsWritten}");
Console.WriteLine("---------------------");

return 0;
