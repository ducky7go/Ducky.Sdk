using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ducky.Sdk.Analyser;

/// <summary>
/// Incremental source generator that mirrors LK key constants into a strongly-typed
/// facade on L with properties that return localized strings via L.Get(key).
///
/// Convention:
/// - Reads nested static classes and const string fields.
/// - Emits partial class L with matching nested static classes and properties.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DuckyLocalizationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Discover LK class declarations by syntax, then enrich with semantic model
        var lkProvider = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax cds && cds.Identifier.Text == "LK",
                static (ctx, ct) => TransformLK(ctx, ct))
            .Where(static info => info is not null)!
            .Select((info, _) => info!);

        // Collect all (usually one) LK descriptors and generate once
        var collected = lkProvider.Collect();
        context.RegisterSourceOutput(collected, static (spc, list) =>
        {
            if (!list.Any())
            {
                return;
            }

            // Now generate for every discovered LK in the compilation.
            foreach (var lk in list)
            {
                if (lk is null) continue;
                Emit(spc, lk);
                EmitKeyListAndHash(spc, lk);
            }
        });
    }

    private static LKDescriptor? TransformLK(GeneratorSyntaxContext ctx, CancellationToken ct)
    {
        var cds = (ClassDeclarationSyntax)ctx.Node;
        if (ctx.SemanticModel.GetDeclaredSymbol(cds, ct) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var ns = symbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty) ?? string.Empty;

        // Only consider static classes named LK
        if (symbol.Name != "LK" || symbol.TypeKind != TypeKind.Class || !symbol.IsStatic)
        {
            return null;
        }

        var groups = new List<GroupDescriptor>();
        foreach (var nested in symbol.GetTypeMembers())
        {
            // Only nested static classes
            if (!nested.IsStatic || nested.TypeKind != TypeKind.Class)
            {
                continue;
            }

            var entries = new List<EntryDescriptor>();
            foreach (var member in nested.GetMembers())
            {
                if (member is IFieldSymbol field && field.IsConst &&
                    field.Type.SpecialType == SpecialType.System_String)
                {
                    var name = field.Name;
                    var value = field.ConstantValue as string ?? string.Empty;
                    if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(value))
                    {
                        entries.Add(new EntryDescriptor(name, value));
                    }
                }
            }

            if (entries.Count > 0)
            {
                groups.Add(new GroupDescriptor(nested.Name, entries));
            }
        }

        if (groups.Count == 0)
        {
            return null;
        }

        return new LKDescriptor(ns, groups);
    }

    /// <summary>
    /// 生成 L 的部分类代码
    /// </summary>
    private static void Emit(SourceProductionContext spc, LKDescriptor lk)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/> DO NOT EDIT");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("namespace Ducky.Sdk.Localizations;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated strongly-typed accessors for BetterModLoader localizations.");
        sb.AppendLine("/// Mirrors LK constants as properties that call L.Get(…)");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public partial class L");
        sb.AppendLine("{");

        foreach (var group in lk.Groups.OrderBy(g => g.Name))
        {
            sb.AppendLine($"    /// <summary>Localized strings for {EscapeXml(group.Name)}</summary>");
            sb.AppendLine($"    public static class {EscapeIdentifier(group.Name)}");
            sb.AppendLine("    {");

            foreach (var entry in group.Entries.OrderBy(e => e.Name))
            {
                // Property that returns L.Get(LK.Group.Name)
                sb.AppendLine($"        /// <summary>Localized text for key: {EscapeXml(entry.Value)}</summary>");
                sb.AppendLine(
                    $"        public static string {EscapeIdentifier(entry.Name)} => Get(global::{lk.Namespace}.LK.{group.Name}.{entry.Name});");
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        // Use a file-name that includes the LK namespace so multiple LK from different namespaces
        // do not collide when generating in the same compilation.
        var fileName = $"L.GeneratedKeys.{MakeSafeFileName(lk.Namespace)}.g.cs";
        spc.AddSource(fileName, sb.ToString());
    }

    /// <summary>
    /// 生成所有 key 的列表和 hash 文件，供 MSBuild Task 使用
    /// 方案：生成一个包含 JSON 字面量的 .cs 文件，MSBuild Target 可以读取生成的源文件并提取 JSON
    /// </summary>
    private static void EmitKeyListAndHash(Microsoft.CodeAnalysis.SourceProductionContext spc, LKDescriptor lk)
    {
        // 收集所有 key（排除重复）
        var allKeys = lk.Groups
            .SelectMany(g => g.Entries)
            .Select(e => e.Value)
            .Distinct()
            .OrderBy(x => x)
            .ToList();

        // 生成 hash
        var hash = ComputeSha256(string.Join("|", allKeys));

        // 构建 JSON 字符串
        var json = new StringBuilder();
        json.AppendLine("{");
        json.AppendLine($"  \"namespace\": \"{EscapeJson(lk.Namespace)}\",");
        json.AppendLine($"  \"hash\": \"{EscapeJson(hash)}\",");
        json.AppendLine($"  \"keyCount\": {allKeys.Count},");
        json.AppendLine("  \"keys\": [");
        for (int i = 0; i < allKeys.Count; i++)
        {
            var comma = i < allKeys.Count - 1 ? "," : "";
            json.AppendLine($"    \"{EscapeJson(allKeys[i])}\"{comma}");
        }
        json.AppendLine("  ]");
        json.Append("}");

        var jsonContent = json.ToString();

        // 生成一个 .cs 文件，包含 JSON 作为字符串常量
        // MSBuild Target 可以通过读取这个生成的源文件来获取 JSON
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated/> DO NOT EDIT");
        code.AppendLine("// This file contains localization keys metadata as a JSON string constant.");
        code.AppendLine("// MSBuild targets can read this source file to extract the JSON.");
        code.AppendLine("#nullable enable");
        code.AppendLine($"namespace {lk.Namespace};");
        code.AppendLine();
        code.AppendLine("/// <summary>");
        code.AppendLine("/// Contains localization keys metadata in JSON format.");
        code.AppendLine("/// This class exists solely to make the JSON data available to build-time tools.");
        code.AppendLine("/// </summary>");
        code.AppendLine("[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]");
        code.AppendLine("internal static class LKeysMetadata");
        code.AppendLine("{");
        code.AppendLine("    /// <summary>JSON metadata - DO NOT MODIFY</summary>");
        code.AppendLine("    internal const string JsonData = @\"");
        
        // 将 JSON 转义后嵌入到 C# 字符串字面量中（使用逐字字符串 @"..."）
        // 在逐字字符串中，只需要将 " 转义为 ""
        var escapedJson = jsonContent.Replace("\"", "\"\"");
        code.Append(escapedJson);
        
        code.AppendLine("\";");
        code.AppendLine();
        code.AppendLine($"    internal const string Hash = \"{EscapeString(hash)}\";");
        code.AppendLine($"    internal const int KeyCount = {allKeys.Count};");
        code.AppendLine("}");

        var metadataFile = $"LKeys.{MakeSafeFileName(lk.Namespace)}.metadata.g.cs";
        spc.AddSource(metadataFile, code.ToString());
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private static string EscapeJson(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        var sb = new StringBuilder(s.Length);
        foreach (var c in s)
        {
            switch (c)
            {
                case '\\': sb.Append("\\\\"); break;
                case '"': sb.Append("\\\""); break;
                case '\n': sb.Append("\\n"); break;
                case '\r': sb.Append("\\r"); break;
                case '\t': sb.Append("\\t"); break;
                case '\b': sb.Append("\\b"); break;
                case '\f': sb.Append("\\f"); break;
                default:
                    if (c < 32)
                        sb.Append($"\\u{(int)c:x4}");
                    else
                        sb.Append(c);
                    break;
            }
        }
        return sb.ToString();
    }

    private static string ComputeSha256(string input)
    {
        using var sha = System.Security.Cryptography.SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(input);
        var hash = sha.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", string.Empty).ToLowerInvariant();
    }

    private static string EscapeIdentifier(string name)
    {
        // Escape keywords or invalid identifiers minimally
        return Microsoft.CodeAnalysis.CSharp.SyntaxFacts.GetKeywordKind(name) !=
               Microsoft.CodeAnalysis.CSharp.SyntaxKind.None
            ? "@" + name
            : name;
    }

    private static string EscapeXml(string text)
    {
        return text.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }

    private static string MakeSafeFileName(string ns)
    {
        if (string.IsNullOrWhiteSpace(ns))
        {
            return "global";
        }

        // Replace dots and invalid filename chars with '_' to create a predictable file name.
        var sb = new StringBuilder();
        foreach (var c in ns)
        {
            if (char.IsLetterOrDigit(c) || c == '_') sb.Append(c);
            else sb.Append('_');
        }

        return sb.ToString();
    }

    private sealed record LKDescriptor(string Namespace, IReadOnlyList<GroupDescriptor> Groups)
    {
        public string Namespace { get; } = Namespace;
        public IReadOnlyList<GroupDescriptor> Groups { get; } = Groups;
    }

    private sealed record GroupDescriptor(string Name, IReadOnlyList<EntryDescriptor> Entries)
    {
        public string Name { get; } = Name;
        public IReadOnlyList<EntryDescriptor> Entries { get; } = Entries;
    }

    private sealed record EntryDescriptor(string Name, string Value)
    {
        public string Name { get; } = Name;
        public string Value { get; } = Value;
    }
}
